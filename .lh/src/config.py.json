{
    "sourceFile": "src/config.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 8,
            "patches": [
                {
                    "date": 1700771052570,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1700771061179,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,13 @@\n #Funções para criptografar os dados\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+\r\n def cript(nome):\r\n      cipher_suite = Fernet(chave_bytes)\r\n      print(cipher_suite)\r\n      texto_criptografado = cipher_suite.encrypt(json.dumps(nome, ensure_ascii=False).encode('utf-8'))\r\n"
                },
                {
                    "date": 1700771089764,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,13 +1,25 @@\n #Funções para criptografar os dados\r\n+import requests\r\n+from bs4 import BeautifulSoup\r\n+import math\r\n+import re\r\n+from datetime import datetime\r\n+import locale\r\n+from cryptography.fernet import Fernet\r\n+import json\r\n+import tempfile\r\n+import pysftp\r\n+import os\r\n+import psycopg2\r\n+from dotenv import load_dotenv\r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n-\r\n def cript(nome):\r\n      cipher_suite = Fernet(chave_bytes)\r\n      print(cipher_suite)\r\n      texto_criptografado = cipher_suite.encrypt(json.dumps(nome, ensure_ascii=False).encode('utf-8'))\r\n"
                },
                {
                    "date": 1700771110246,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,140 @@\n+#Funções para criptografar os dados\r\n+import requests\r\n+from bs4 import BeautifulSoup\r\n+import math\r\n+import re\r\n+from datetime import datetime\r\n+import locale\r\n+from cryptography.fernet import Fernet\r\n+import json\r\n+import tempfile\r\n+import pysftp\r\n+import os\r\n+import psycopg2\r\n+from dotenv import load_dotenv\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+# Carrega variáveis de ambiente do arquivo .env\r\n+load_dotenv()\r\n+\r\n+def cript(nome):\r\n+     cipher_suite = Fernet(chave_bytes)\r\n+     print(cipher_suite)\r\n+     texto_criptografado = cipher_suite.encrypt(json.dumps(nome, ensure_ascii=False).encode('utf-8'))\r\n+     return texto_criptografado\r\n+\r\n+def descriptografia_e_envio(texto_criptografado,sua_tabela,chave_unica):\r\n+     # Configurações de conexão SFTP\r\n+     host = os.getenv('host')\r\n+     username = os.getenv('username')\r\n+     port = 22  # Porta padrão para SFTP\r\n+     password = os.getenv('password')  # ou use chave privada com cnopt.private_key_file\r\n+     cnopts = pysftp.CnOpts()\r\n+     cnopts.hostkeys = None  # Desativa a verificação do hostkey\r\n+     \r\n+     with tempfile.NamedTemporaryFile(delete=False, suffix='.txt') as temp_file:\r\n+          temp_filename = temp_file.name\r\n+          temp_file.write(texto_criptografado)\r\n+          temp_file.seek(0)\r\n+          temp_file.close()\r\n+          \r\n+\r\n+          with pysftp.Connection(host, username=username, password=password, port=port, cnopts=cnopts) as sftp:\r\n+               remote_path_upload = r'C:\\Users\\Lenovo\\Desktop\\Projeto Data WH\\saida dados\\teste.txt'\r\n+               sftp.put(temp_filename, remote_path_upload)\r\n+               \r\n+               \r\n+               os.remove(temp_filename)\r\n+          \r\n+               # Fazer download de um arquivo do servidor SFTP\r\n+               remote_path_download = r'C:\\Users\\Lenovo\\Desktop\\Projeto Data WH\\saida dados\\teste.txt'\r\n+               local_path_download = 'caminho_do_arquivo_remoto_para_baixar.txt'\r\n+               sftp.get(remote_path_download, local_path_download)\r\n+                \r\n+       \r\n+     # Descriptografar os dados do arquivo criptografado\r\n+     with open(local_path_download, 'rb') as arquivo_criptografado:\r\n+          dados_criptografados = arquivo_criptografado.read().decode('utf-8') \r\n+          cipher_suite = Fernet(chave_bytes)      \r\n+          texto_descriptrografado = cipher_suite.decrypt(dados_criptografados)\r\n+          dados_descriptrografado = texto_descriptrografado.decode('utf-8')\r\n+          dicionario_descriptrografado = json.loads(dados_descriptrografado)\r\n+          \r\n+          \r\n+     chaves = []\r\n+     valores = []\r\n+     \r\n+     for dicionario in dicionario_descriptrografado:\r\n+          for chav, valor in dicionario.items():\r\n+               chaves.append(chav)\r\n+               valores.append(valor)\r\n+               \r\n+               \r\n+     db_config = {\r\n+          'host': os.getenv('DBhost'),\r\n+          'database': os.getenv('DBdatabase'),\r\n+          'user': os.getenv('DBuser'),\r\n+          'password': os.getenv('DBpassword')\r\n+     }\r\n+     \r\n+     # Crie uma conexão com o banco de dados PostgreSQL\r\n+     try:\r\n+          conexao = psycopg2.connect(**db_config)\r\n+          cursor = conexao.cursor()\r\n+          ######################################################################################\r\n+          # Consulte o banco de dados para obter as chaves existentes\r\n+          consulta_sql = f\"SELECT {chave_unica} FROM {sua_tabela};\"\r\n+          # Execute a consulta SQL\r\n+          cursor.execute(consulta_sql)\r\n+          dados_do_banco = cursor.fetchall()\r\n+          print(consulta_sql)\r\n+          \r\n+          # Execute a consulta SQL para obter as chaves únicas existentes no banco de dados\r\n+          chave_desejada = f\"{chave_unica}\"\r\n+          \r\n+          chaves_existente = [valor for tupla in dados_do_banco for valor in tupla]\r\n+          chaves_existente = set(chaves_existente)\r\n+          print(chaves_existente)\r\n+\r\n+          chaves_novas = {dicionario[chave_desejada] for dicionario in dicionario_descriptrografado}\r\n+          print(chaves_novas)\r\n+\r\n+      \r\n+\r\n+          # Importe apenas as chaves que ainda não existem no banco de dados\r\n+          novas_chaves = chaves_novas - chaves_existente\r\n+          print(novas_chaves)\r\n+          \r\n+          dados_para_inserir = []\r\n+\r\n+          for dicionario in dicionario_descriptrografado:\r\n+          # Verifica se a chave desejada está presente no dicionário\r\n+               if dicionario[chave_desejada] in novas_chaves:\r\n+                    # Adiciona o dicionário completo à lista\r\n+                    dados_para_inserir.append(dicionario)\r\n+                    # Construa a consulta SQL INSERT\r\n+          for dicionario_inserir in dados_para_inserir:\r\n+               consulta_sql = f\"INSERT INTO {sua_tabela} ({', '.join(dicionario_inserir.keys())}) VALUES ({', '.join(['%s' for _ in dicionario_inserir.values()])})\"\r\n+\r\n+               # Execute a consulta SQL\r\n+               cursor.execute(consulta_sql)\r\n+\r\n+               # Faça commit para confirmar a transação\r\n+               conexao.commit()\r\n+               print(\"Inserção bem-sucedida.\")\r\n+\r\n+     except Exception as e:\r\n+          print(\"Erro ao executar a consulta SQL:\", e)\r\n+          # Lide com o erro conforme necessário\r\n+\r\n+     finally:\r\n+     # Feche a conexão com o banco de dados\r\n+          if conexao:\r\n+               cursor.close()\r\n+               conexao.close()\r\n+          \r\n+     return dados_descriptrografado\r\n+     \n\\ No newline at end of file\n"
                },
                {
                    "date": 1700771125517,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,141 @@\n+#Funções para criptografar os dados\r\n+import requests\r\n+from bs4 import BeautifulSoup\r\n+import math\r\n+import re\r\n+from datetime import datetime\r\n+import locale\r\n+from cryptography.fernet import Fernet\r\n+import json\r\n+import tempfile\r\n+import pysftp\r\n+import os\r\n+import psycopg2\r\n+from dotenv import load_dotenv\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+# Carrega variáveis de ambiente do arquivo .env\r\n+load_dotenv()\r\n+\r\n+\r\n+def cript(nome):\r\n+     cipher_suite = Fernet(chave_bytes)\r\n+     print(cipher_suite)\r\n+     texto_criptografado = cipher_suite.encrypt(json.dumps(nome, ensure_ascii=False).encode('utf-8'))\r\n+     return texto_criptografado\r\n+\r\n+def descriptografia_e_envio(texto_criptografado,sua_tabela,chave_unica):\r\n+     # Configurações de conexão SFTP\r\n+     host = os.getenv('host')\r\n+     username = os.getenv('username')\r\n+     port = 22  # Porta padrão para SFTP\r\n+     password = os.getenv('password')  # ou use chave privada com cnopt.private_key_file\r\n+     cnopts = pysftp.CnOpts()\r\n+     cnopts.hostkeys = None  # Desativa a verificação do hostkey\r\n+     \r\n+     with tempfile.NamedTemporaryFile(delete=False, suffix='.txt') as temp_file:\r\n+          temp_filename = temp_file.name\r\n+          temp_file.write(texto_criptografado)\r\n+          temp_file.seek(0)\r\n+          temp_file.close()\r\n+          \r\n+\r\n+          with pysftp.Connection(host, username=username, password=password, port=port, cnopts=cnopts) as sftp:\r\n+               remote_path_upload = r'C:\\Users\\Lenovo\\Desktop\\Projeto Data WH\\saida dados\\teste.txt'\r\n+               sftp.put(temp_filename, remote_path_upload)\r\n+               \r\n+               \r\n+               os.remove(temp_filename)\r\n+          \r\n+               # Fazer download de um arquivo do servidor SFTP\r\n+               remote_path_download = r'C:\\Users\\Lenovo\\Desktop\\Projeto Data WH\\saida dados\\teste.txt'\r\n+               local_path_download = 'caminho_do_arquivo_remoto_para_baixar.txt'\r\n+               sftp.get(remote_path_download, local_path_download)\r\n+                \r\n+       \r\n+     # Descriptografar os dados do arquivo criptografado\r\n+     with open(local_path_download, 'rb') as arquivo_criptografado:\r\n+          dados_criptografados = arquivo_criptografado.read().decode('utf-8') \r\n+          cipher_suite = Fernet(chave_bytes)      \r\n+          texto_descriptrografado = cipher_suite.decrypt(dados_criptografados)\r\n+          dados_descriptrografado = texto_descriptrografado.decode('utf-8')\r\n+          dicionario_descriptrografado = json.loads(dados_descriptrografado)\r\n+          \r\n+          \r\n+     chaves = []\r\n+     valores = []\r\n+     \r\n+     for dicionario in dicionario_descriptrografado:\r\n+          for chav, valor in dicionario.items():\r\n+               chaves.append(chav)\r\n+               valores.append(valor)\r\n+               \r\n+               \r\n+     db_config = {\r\n+          'host': os.getenv('DBhost'),\r\n+          'database': os.getenv('DBdatabase'),\r\n+          'user': os.getenv('DBuser'),\r\n+          'password': os.getenv('DBpassword')\r\n+     }\r\n+     \r\n+     # Crie uma conexão com o banco de dados PostgreSQL\r\n+     try:\r\n+          conexao = psycopg2.connect(**db_config)\r\n+          cursor = conexao.cursor()\r\n+          ######################################################################################\r\n+          # Consulte o banco de dados para obter as chaves existentes\r\n+          consulta_sql = f\"SELECT {chave_unica} FROM {sua_tabela};\"\r\n+          # Execute a consulta SQL\r\n+          cursor.execute(consulta_sql)\r\n+          dados_do_banco = cursor.fetchall()\r\n+          print(consulta_sql)\r\n+          \r\n+          # Execute a consulta SQL para obter as chaves únicas existentes no banco de dados\r\n+          chave_desejada = f\"{chave_unica}\"\r\n+          \r\n+          chaves_existente = [valor for tupla in dados_do_banco for valor in tupla]\r\n+          chaves_existente = set(chaves_existente)\r\n+          print(chaves_existente)\r\n+\r\n+          chaves_novas = {dicionario[chave_desejada] for dicionario in dicionario_descriptrografado}\r\n+          print(chaves_novas)\r\n+\r\n+      \r\n+\r\n+          # Importe apenas as chaves que ainda não existem no banco de dados\r\n+          novas_chaves = chaves_novas - chaves_existente\r\n+          print(novas_chaves)\r\n+          \r\n+          dados_para_inserir = []\r\n+\r\n+          for dicionario in dicionario_descriptrografado:\r\n+          # Verifica se a chave desejada está presente no dicionário\r\n+               if dicionario[chave_desejada] in novas_chaves:\r\n+                    # Adiciona o dicionário completo à lista\r\n+                    dados_para_inserir.append(dicionario)\r\n+                    # Construa a consulta SQL INSERT\r\n+          for dicionario_inserir in dados_para_inserir:\r\n+               consulta_sql = f\"INSERT INTO {sua_tabela} ({', '.join(dicionario_inserir.keys())}) VALUES ({', '.join(['%s' for _ in dicionario_inserir.values()])})\"\r\n+\r\n+               # Execute a consulta SQL\r\n+               cursor.execute(consulta_sql)\r\n+\r\n+               # Faça commit para confirmar a transação\r\n+               conexao.commit()\r\n+               print(\"Inserção bem-sucedida.\")\r\n+\r\n+     except Exception as e:\r\n+          print(\"Erro ao executar a consulta SQL:\", e)\r\n+          # Lide com o erro conforme necessário\r\n+\r\n+     finally:\r\n+     # Feche a conexão com o banco de dados\r\n+          if conexao:\r\n+               cursor.close()\r\n+               conexao.close()\r\n+          \r\n+     return dados_descriptrografado\r\n+     \n\\ No newline at end of file\n"
                },
                {
                    "date": 1700771247545,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,147 +1,6 @@\n #Funções para criptografar os dados\r\n-import requests\r\n-from bs4 import BeautifulSoup\r\n-import math\r\n-import re\r\n-from datetime import datetime\r\n-import locale\r\n-from cryptography.fernet import Fernet\r\n-import json\r\n-import tempfile\r\n-import pysftp\r\n-import os\r\n-import psycopg2\r\n-from dotenv import load_dotenv\r\n \r\n-\r\n-\r\n-\r\n-\r\n-# Carrega variáveis de ambiente do arquivo .env\r\n-load_dotenv()\r\n-\r\n-\r\n-def cript(nome):\r\n-     cipher_suite = Fernet(chave_bytes)\r\n-     print(cipher_suite)\r\n-     texto_criptografado = cipher_suite.encrypt(json.dumps(nome, ensure_ascii=False).encode('utf-8'))\r\n-     return texto_criptografado\r\n-\r\n-def descriptografia_e_envio(texto_criptografado,sua_tabela,chave_unica):\r\n-     # Configurações de conexão SFTP\r\n-     host = os.getenv('host')\r\n-     username = os.getenv('username')\r\n-     port = 22  # Porta padrão para SFTP\r\n-     password = os.getenv('password')  # ou use chave privada com cnopt.private_key_file\r\n-     cnopts = pysftp.CnOpts()\r\n-     cnopts.hostkeys = None  # Desativa a verificação do hostkey\r\n-     \r\n-     with tempfile.NamedTemporaryFile(delete=False, suffix='.txt') as temp_file:\r\n-          temp_filename = temp_file.name\r\n-          temp_file.write(texto_criptografado)\r\n-          temp_file.seek(0)\r\n-          temp_file.close()\r\n-          \r\n-\r\n-          with pysftp.Connection(host, username=username, password=password, port=port, cnopts=cnopts) as sftp:\r\n-               remote_path_upload = r'C:\\Users\\Lenovo\\Desktop\\Projeto Data WH\\saida dados\\teste.txt'\r\n-               sftp.put(temp_filename, remote_path_upload)\r\n-               \r\n-               \r\n-               os.remove(temp_filename)\r\n-          \r\n-               # Fazer download de um arquivo do servidor SFTP\r\n-               remote_path_download = r'C:\\Users\\Lenovo\\Desktop\\Projeto Data WH\\saida dados\\teste.txt'\r\n-               local_path_download = 'caminho_do_arquivo_remoto_para_baixar.txt'\r\n-               sftp.get(remote_path_download, local_path_download)\r\n-                \r\n-       \r\n-     # Descriptografar os dados do arquivo criptografado\r\n-     with open(local_path_download, 'rb') as arquivo_criptografado:\r\n-          dados_criptografados = arquivo_criptografado.read().decode('utf-8') \r\n-          cipher_suite = Fernet(chave_bytes)      \r\n-          texto_descriptrografado = cipher_suite.decrypt(dados_criptografados)\r\n-          dados_descriptrografado = texto_descriptrografado.decode('utf-8')\r\n-          dicionario_descriptrografado = json.loads(dados_descriptrografado)\r\n-          \r\n-          \r\n-     chaves = []\r\n-     valores = []\r\n-     \r\n-     for dicionario in dicionario_descriptrografado:\r\n-          for chav, valor in dicionario.items():\r\n-               chaves.append(chav)\r\n-               valores.append(valor)\r\n-               \r\n-               \r\n-     db_config = {\r\n-          'host': os.getenv('DBhost'),\r\n-          'database': os.getenv('DBdatabase'),\r\n-          'user': os.getenv('DBuser'),\r\n-          'password': os.getenv('DBpassword')\r\n-     }\r\n-     \r\n-     # Crie uma conexão com o banco de dados PostgreSQL\r\n-     try:\r\n-          conexao = psycopg2.connect(**db_config)\r\n-          cursor = conexao.cursor()\r\n-          ######################################################################################\r\n-          # Consulte o banco de dados para obter as chaves existentes\r\n-          consulta_sql = f\"SELECT {chave_unica} FROM {sua_tabela};\"\r\n-          # Execute a consulta SQL\r\n-          cursor.execute(consulta_sql)\r\n-          dados_do_banco = cursor.fetchall()\r\n-          print(consulta_sql)\r\n-          \r\n-          # Execute a consulta SQL para obter as chaves únicas existentes no banco de dados\r\n-          chave_desejada = f\"{chave_unica}\"\r\n-          \r\n-          chaves_existente = [valor for tupla in dados_do_banco for valor in tupla]\r\n-          chaves_existente = set(chaves_existente)\r\n-          print(chaves_existente)\r\n-\r\n-          chaves_novas = {dicionario[chave_desejada] for dicionario in dicionario_descriptrografado}\r\n-          print(chaves_novas)\r\n-\r\n-      \r\n-\r\n-          # Importe apenas as chaves que ainda não existem no banco de dados\r\n-          novas_chaves = chaves_novas - chaves_existente\r\n-          print(novas_chaves)\r\n-          \r\n-          dados_para_inserir = []\r\n-\r\n-          for dicionario in dicionario_descriptrografado:\r\n-          # Verifica se a chave desejada está presente no dicionário\r\n-               if dicionario[chave_desejada] in novas_chaves:\r\n-                    # Adiciona o dicionário completo à lista\r\n-                    dados_para_inserir.append(dicionario)\r\n-                    # Construa a consulta SQL INSERT\r\n-          for dicionario_inserir in dados_para_inserir:\r\n-               consulta_sql = f\"INSERT INTO {sua_tabela} ({', '.join(dicionario_inserir.keys())}) VALUES ({', '.join(['%s' for _ in dicionario_inserir.values()])})\"\r\n-\r\n-               # Execute a consulta SQL\r\n-               cursor.execute(consulta_sql)\r\n-\r\n-               # Faça commit para confirmar a transação\r\n-               conexao.commit()\r\n-               print(\"Inserção bem-sucedida.\")\r\n-\r\n-     except Exception as e:\r\n-          print(\"Erro ao executar a consulta SQL:\", e)\r\n-          # Lide com o erro conforme necessário\r\n-\r\n-     finally:\r\n-     # Feche a conexão com o banco de dados\r\n-          if conexao:\r\n-               cursor.close()\r\n-               conexao.close()\r\n-          \r\n-     return dados_descriptrografado\r\n-     \n-#Funções para criptografar os dados\r\n-import requests\r\n from bs4 import BeautifulSoup\r\n import math\r\n import re\r\n from datetime import datetime\r\n@@ -159,8 +18,9 @@\n \r\n \r\n # Carrega variáveis de ambiente do arquivo .env\r\n load_dotenv()\r\n+chave_bytes = os.getenv('chave').encode('utf-8')\r\n \r\n def cript(nome):\r\n      cipher_suite = Fernet(chave_bytes)\r\n      print(cipher_suite)\r\n@@ -277,144 +137,5 @@\n                cursor.close()\r\n                conexao.close()\r\n           \r\n      return dados_descriptrografado\r\n-     \n-#Funções para criptografar os dados\r\n-import requests\r\n-from bs4 import BeautifulSoup\r\n-import math\r\n-import re\r\n-from datetime import datetime\r\n-import locale\r\n-from cryptography.fernet import Fernet\r\n-import json\r\n-import tempfile\r\n-import pysftp\r\n-import os\r\n-import psycopg2\r\n-from dotenv import load_dotenv\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-def cript(nome):\r\n-     cipher_suite = Fernet(chave_bytes)\r\n-     print(cipher_suite)\r\n-     texto_criptografado = cipher_suite.encrypt(json.dumps(nome, ensure_ascii=False).encode('utf-8'))\r\n-     return texto_criptografado\r\n-\r\n-def descriptografia_e_envio(texto_criptografado,sua_tabela,chave_unica):\r\n-     # Configurações de conexão SFTP\r\n-     host = os.getenv('host')\r\n-     username = os.getenv('username')\r\n-     port = 22  # Porta padrão para SFTP\r\n-     password = os.getenv('password')  # ou use chave privada com cnopt.private_key_file\r\n-     cnopts = pysftp.CnOpts()\r\n-     cnopts.hostkeys = None  # Desativa a verificação do hostkey\r\n-     \r\n-     with tempfile.NamedTemporaryFile(delete=False, suffix='.txt') as temp_file:\r\n-          temp_filename = temp_file.name\r\n-          temp_file.write(texto_criptografado)\r\n-          temp_file.seek(0)\r\n-          temp_file.close()\r\n-          \r\n-\r\n-          with pysftp.Connection(host, username=username, password=password, port=port, cnopts=cnopts) as sftp:\r\n-               remote_path_upload = r'C:\\Users\\Lenovo\\Desktop\\Projeto Data WH\\saida dados\\teste.txt'\r\n-               sftp.put(temp_filename, remote_path_upload)\r\n-               \r\n-               \r\n-               os.remove(temp_filename)\r\n-          \r\n-               # Fazer download de um arquivo do servidor SFTP\r\n-               remote_path_download = r'C:\\Users\\Lenovo\\Desktop\\Projeto Data WH\\saida dados\\teste.txt'\r\n-               local_path_download = 'caminho_do_arquivo_remoto_para_baixar.txt'\r\n-               sftp.get(remote_path_download, local_path_download)\r\n-                \r\n-       \r\n-     # Descriptografar os dados do arquivo criptografado\r\n-     with open(local_path_download, 'rb') as arquivo_criptografado:\r\n-          dados_criptografados = arquivo_criptografado.read().decode('utf-8') \r\n-          cipher_suite = Fernet(chave_bytes)      \r\n-          texto_descriptrografado = cipher_suite.decrypt(dados_criptografados)\r\n-          dados_descriptrografado = texto_descriptrografado.decode('utf-8')\r\n-          dicionario_descriptrografado = json.loads(dados_descriptrografado)\r\n-          \r\n-          \r\n-     chaves = []\r\n-     valores = []\r\n-     \r\n-     for dicionario in dicionario_descriptrografado:\r\n-          for chav, valor in dicionario.items():\r\n-               chaves.append(chav)\r\n-               valores.append(valor)\r\n-               \r\n-               \r\n-     db_config = {\r\n-          'host': os.getenv('DBhost'),\r\n-          'database': os.getenv('DBdatabase'),\r\n-          'user': os.getenv('DBuser'),\r\n-          'password': os.getenv('DBpassword')\r\n-     }\r\n-     \r\n-     # Crie uma conexão com o banco de dados PostgreSQL\r\n-     try:\r\n-          conexao = psycopg2.connect(**db_config)\r\n-          cursor = conexao.cursor()\r\n-          ######################################################################################\r\n-          # Consulte o banco de dados para obter as chaves existentes\r\n-          consulta_sql = f\"SELECT {chave_unica} FROM {sua_tabela};\"\r\n-          # Execute a consulta SQL\r\n-          cursor.execute(consulta_sql)\r\n-          dados_do_banco = cursor.fetchall()\r\n-          print(consulta_sql)\r\n-          \r\n-          # Execute a consulta SQL para obter as chaves únicas existentes no banco de dados\r\n-          chave_desejada = f\"{chave_unica}\"\r\n-          \r\n-          chaves_existente = [valor for tupla in dados_do_banco for valor in tupla]\r\n-          chaves_existente = set(chaves_existente)\r\n-          print(chaves_existente)\r\n-\r\n-          chaves_novas = {dicionario[chave_desejada] for dicionario in dicionario_descriptrografado}\r\n-          print(chaves_novas)\r\n-\r\n-      \r\n-\r\n-          # Importe apenas as chaves que ainda não existem no banco de dados\r\n-          novas_chaves = chaves_novas - chaves_existente\r\n-          print(novas_chaves)\r\n-          \r\n-          dados_para_inserir = []\r\n-\r\n-          for dicionario in dicionario_descriptrografado:\r\n-          # Verifica se a chave desejada está presente no dicionário\r\n-               if dicionario[chave_desejada] in novas_chaves:\r\n-                    # Adiciona o dicionário completo à lista\r\n-                    dados_para_inserir.append(dicionario)\r\n-                    # Construa a consulta SQL INSERT\r\n-          for dicionario_inserir in dados_para_inserir:\r\n-               consulta_sql = f\"INSERT INTO {sua_tabela} ({', '.join(dicionario_inserir.keys())}) VALUES ({', '.join(['%s' for _ in dicionario_inserir.values()])})\"\r\n-\r\n-               # Execute a consulta SQL\r\n-               cursor.execute(consulta_sql)\r\n-\r\n-               # Faça commit para confirmar a transação\r\n-               conexao.commit()\r\n-               print(\"Inserção bem-sucedida.\")\r\n-\r\n-     except Exception as e:\r\n-          print(\"Erro ao executar a consulta SQL:\", e)\r\n-          # Lide com o erro conforme necessário\r\n-\r\n-     finally:\r\n-     # Feche a conexão com o banco de dados\r\n-          if conexao:\r\n-               cursor.close()\r\n-               conexao.close()\r\n-          \r\n-     return dados_descriptrografado\r\n      \n\\ No newline at end of file\n"
                },
                {
                    "date": 1700771253150,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,138 @@\n+#Funções para criptografar os dados\r\n+from bs4 import BeautifulSoup\r\n+from datetime import datetime\r\n+import locale\r\n+from cryptography.fernet import Fernet\r\n+import json\r\n+import tempfile\r\n+import pysftp\r\n+import os\r\n+import psycopg2\r\n+from dotenv import load_dotenv\r\n+\r\n+\r\n+\r\n+\r\n+\r\n+# Carrega variáveis de ambiente do arquivo .env\r\n+load_dotenv()\r\n+chave_bytes = os.getenv('chave').encode('utf-8')\r\n+\r\n+def cript(nome):\r\n+     cipher_suite = Fernet(chave_bytes)\r\n+     print(cipher_suite)\r\n+     texto_criptografado = cipher_suite.encrypt(json.dumps(nome, ensure_ascii=False).encode('utf-8'))\r\n+     return texto_criptografado\r\n+\r\n+def descriptografia_e_envio(texto_criptografado,sua_tabela,chave_unica):\r\n+     # Configurações de conexão SFTP\r\n+     host = os.getenv('host')\r\n+     username = os.getenv('username')\r\n+     port = 22  # Porta padrão para SFTP\r\n+     password = os.getenv('password')  # ou use chave privada com cnopt.private_key_file\r\n+     cnopts = pysftp.CnOpts()\r\n+     cnopts.hostkeys = None  # Desativa a verificação do hostkey\r\n+     \r\n+     with tempfile.NamedTemporaryFile(delete=False, suffix='.txt') as temp_file:\r\n+          temp_filename = temp_file.name\r\n+          temp_file.write(texto_criptografado)\r\n+          temp_file.seek(0)\r\n+          temp_file.close()\r\n+          \r\n+\r\n+          with pysftp.Connection(host, username=username, password=password, port=port, cnopts=cnopts) as sftp:\r\n+               remote_path_upload = r'C:\\Users\\Lenovo\\Desktop\\Projeto Data WH\\saida dados\\teste.txt'\r\n+               sftp.put(temp_filename, remote_path_upload)\r\n+               \r\n+               \r\n+               os.remove(temp_filename)\r\n+          \r\n+               # Fazer download de um arquivo do servidor SFTP\r\n+               remote_path_download = r'C:\\Users\\Lenovo\\Desktop\\Projeto Data WH\\saida dados\\teste.txt'\r\n+               local_path_download = 'caminho_do_arquivo_remoto_para_baixar.txt'\r\n+               sftp.get(remote_path_download, local_path_download)\r\n+                \r\n+       \r\n+     # Descriptografar os dados do arquivo criptografado\r\n+     with open(local_path_download, 'rb') as arquivo_criptografado:\r\n+          dados_criptografados = arquivo_criptografado.read().decode('utf-8') \r\n+          cipher_suite = Fernet(chave_bytes)      \r\n+          texto_descriptrografado = cipher_suite.decrypt(dados_criptografados)\r\n+          dados_descriptrografado = texto_descriptrografado.decode('utf-8')\r\n+          dicionario_descriptrografado = json.loads(dados_descriptrografado)\r\n+          \r\n+          \r\n+     chaves = []\r\n+     valores = []\r\n+     \r\n+     for dicionario in dicionario_descriptrografado:\r\n+          for chav, valor in dicionario.items():\r\n+               chaves.append(chav)\r\n+               valores.append(valor)\r\n+               \r\n+               \r\n+     db_config = {\r\n+          'host': os.getenv('DBhost'),\r\n+          'database': os.getenv('DBdatabase'),\r\n+          'user': os.getenv('DBuser'),\r\n+          'password': os.getenv('DBpassword')\r\n+     }\r\n+     \r\n+     # Crie uma conexão com o banco de dados PostgreSQL\r\n+     try:\r\n+          conexao = psycopg2.connect(**db_config)\r\n+          cursor = conexao.cursor()\r\n+          ######################################################################################\r\n+          # Consulte o banco de dados para obter as chaves existentes\r\n+          consulta_sql = f\"SELECT {chave_unica} FROM {sua_tabela};\"\r\n+          # Execute a consulta SQL\r\n+          cursor.execute(consulta_sql)\r\n+          dados_do_banco = cursor.fetchall()\r\n+          print(consulta_sql)\r\n+          \r\n+          # Execute a consulta SQL para obter as chaves únicas existentes no banco de dados\r\n+          chave_desejada = f\"{chave_unica}\"\r\n+          \r\n+          chaves_existente = [valor for tupla in dados_do_banco for valor in tupla]\r\n+          chaves_existente = set(chaves_existente)\r\n+          print(chaves_existente)\r\n+\r\n+          chaves_novas = {dicionario[chave_desejada] for dicionario in dicionario_descriptrografado}\r\n+          print(chaves_novas)\r\n+\r\n+      \r\n+\r\n+          # Importe apenas as chaves que ainda não existem no banco de dados\r\n+          novas_chaves = chaves_novas - chaves_existente\r\n+          print(novas_chaves)\r\n+          \r\n+          dados_para_inserir = []\r\n+\r\n+          for dicionario in dicionario_descriptrografado:\r\n+          # Verifica se a chave desejada está presente no dicionário\r\n+               if dicionario[chave_desejada] in novas_chaves:\r\n+                    # Adiciona o dicionário completo à lista\r\n+                    dados_para_inserir.append(dicionario)\r\n+                    # Construa a consulta SQL INSERT\r\n+          for dicionario_inserir in dados_para_inserir:\r\n+               consulta_sql = f\"INSERT INTO {sua_tabela} ({', '.join(dicionario_inserir.keys())}) VALUES ({', '.join(['%s' for _ in dicionario_inserir.values()])})\"\r\n+\r\n+               # Execute a consulta SQL\r\n+               cursor.execute(consulta_sql)\r\n+\r\n+               # Faça commit para confirmar a transação\r\n+               conexao.commit()\r\n+               print(\"Inserção bem-sucedida.\")\r\n+\r\n+     except Exception as e:\r\n+          print(\"Erro ao executar a consulta SQL:\", e)\r\n+          # Lide com o erro conforme necessário\r\n+\r\n+     finally:\r\n+     # Feche a conexão com o banco de dados\r\n+          if conexao:\r\n+               cursor.close()\r\n+               conexao.close()\r\n+          \r\n+     return dados_descriptrografado\r\n+     \n\\ No newline at end of file\n"
                },
                {
                    "date": 1700771259653,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,7 @@\n #Funções para criptografar os dados\r\n from bs4 import BeautifulSoup\r\n from datetime import datetime\r\n-import locale\r\n from cryptography.fernet import Fernet\r\n import json\r\n import tempfile\r\n import pysftp\r\n@@ -134,146 +133,5 @@\n                cursor.close()\r\n                conexao.close()\r\n           \r\n      return dados_descriptrografado\r\n-     \n-#Funções para criptografar os dados\r\n-\r\n-from bs4 import BeautifulSoup\r\n-import math\r\n-import re\r\n-from datetime import datetime\r\n-import locale\r\n-from cryptography.fernet import Fernet\r\n-import json\r\n-import tempfile\r\n-import pysftp\r\n-import os\r\n-import psycopg2\r\n-from dotenv import load_dotenv\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-# Carrega variáveis de ambiente do arquivo .env\r\n-load_dotenv()\r\n-chave_bytes = os.getenv('chave').encode('utf-8')\r\n-\r\n-def cript(nome):\r\n-     cipher_suite = Fernet(chave_bytes)\r\n-     print(cipher_suite)\r\n-     texto_criptografado = cipher_suite.encrypt(json.dumps(nome, ensure_ascii=False).encode('utf-8'))\r\n-     return texto_criptografado\r\n-\r\n-def descriptografia_e_envio(texto_criptografado,sua_tabela,chave_unica):\r\n-     # Configurações de conexão SFTP\r\n-     host = os.getenv('host')\r\n-     username = os.getenv('username')\r\n-     port = 22  # Porta padrão para SFTP\r\n-     password = os.getenv('password')  # ou use chave privada com cnopt.private_key_file\r\n-     cnopts = pysftp.CnOpts()\r\n-     cnopts.hostkeys = None  # Desativa a verificação do hostkey\r\n-     \r\n-     with tempfile.NamedTemporaryFile(delete=False, suffix='.txt') as temp_file:\r\n-          temp_filename = temp_file.name\r\n-          temp_file.write(texto_criptografado)\r\n-          temp_file.seek(0)\r\n-          temp_file.close()\r\n-          \r\n-\r\n-          with pysftp.Connection(host, username=username, password=password, port=port, cnopts=cnopts) as sftp:\r\n-               remote_path_upload = r'C:\\Users\\Lenovo\\Desktop\\Projeto Data WH\\saida dados\\teste.txt'\r\n-               sftp.put(temp_filename, remote_path_upload)\r\n-               \r\n-               \r\n-               os.remove(temp_filename)\r\n-          \r\n-               # Fazer download de um arquivo do servidor SFTP\r\n-               remote_path_download = r'C:\\Users\\Lenovo\\Desktop\\Projeto Data WH\\saida dados\\teste.txt'\r\n-               local_path_download = 'caminho_do_arquivo_remoto_para_baixar.txt'\r\n-               sftp.get(remote_path_download, local_path_download)\r\n-                \r\n-       \r\n-     # Descriptografar os dados do arquivo criptografado\r\n-     with open(local_path_download, 'rb') as arquivo_criptografado:\r\n-          dados_criptografados = arquivo_criptografado.read().decode('utf-8') \r\n-          cipher_suite = Fernet(chave_bytes)      \r\n-          texto_descriptrografado = cipher_suite.decrypt(dados_criptografados)\r\n-          dados_descriptrografado = texto_descriptrografado.decode('utf-8')\r\n-          dicionario_descriptrografado = json.loads(dados_descriptrografado)\r\n-          \r\n-          \r\n-     chaves = []\r\n-     valores = []\r\n-     \r\n-     for dicionario in dicionario_descriptrografado:\r\n-          for chav, valor in dicionario.items():\r\n-               chaves.append(chav)\r\n-               valores.append(valor)\r\n-               \r\n-               \r\n-     db_config = {\r\n-          'host': os.getenv('DBhost'),\r\n-          'database': os.getenv('DBdatabase'),\r\n-          'user': os.getenv('DBuser'),\r\n-          'password': os.getenv('DBpassword')\r\n-     }\r\n-     \r\n-     # Crie uma conexão com o banco de dados PostgreSQL\r\n-     try:\r\n-          conexao = psycopg2.connect(**db_config)\r\n-          cursor = conexao.cursor()\r\n-          ######################################################################################\r\n-          # Consulte o banco de dados para obter as chaves existentes\r\n-          consulta_sql = f\"SELECT {chave_unica} FROM {sua_tabela};\"\r\n-          # Execute a consulta SQL\r\n-          cursor.execute(consulta_sql)\r\n-          dados_do_banco = cursor.fetchall()\r\n-          print(consulta_sql)\r\n-          \r\n-          # Execute a consulta SQL para obter as chaves únicas existentes no banco de dados\r\n-          chave_desejada = f\"{chave_unica}\"\r\n-          \r\n-          chaves_existente = [valor for tupla in dados_do_banco for valor in tupla]\r\n-          chaves_existente = set(chaves_existente)\r\n-          print(chaves_existente)\r\n-\r\n-          chaves_novas = {dicionario[chave_desejada] for dicionario in dicionario_descriptrografado}\r\n-          print(chaves_novas)\r\n-\r\n-      \r\n-\r\n-          # Importe apenas as chaves que ainda não existem no banco de dados\r\n-          novas_chaves = chaves_novas - chaves_existente\r\n-          print(novas_chaves)\r\n-          \r\n-          dados_para_inserir = []\r\n-\r\n-          for dicionario in dicionario_descriptrografado:\r\n-          # Verifica se a chave desejada está presente no dicionário\r\n-               if dicionario[chave_desejada] in novas_chaves:\r\n-                    # Adiciona o dicionário completo à lista\r\n-                    dados_para_inserir.append(dicionario)\r\n-                    # Construa a consulta SQL INSERT\r\n-          for dicionario_inserir in dados_para_inserir:\r\n-               consulta_sql = f\"INSERT INTO {sua_tabela} ({', '.join(dicionario_inserir.keys())}) VALUES ({', '.join(['%s' for _ in dicionario_inserir.values()])})\"\r\n-\r\n-               # Execute a consulta SQL\r\n-               cursor.execute(consulta_sql)\r\n-\r\n-               # Faça commit para confirmar a transação\r\n-               conexao.commit()\r\n-               print(\"Inserção bem-sucedida.\")\r\n-\r\n-     except Exception as e:\r\n-          print(\"Erro ao executar a consulta SQL:\", e)\r\n-          # Lide com o erro conforme necessário\r\n-\r\n-     finally:\r\n-     # Feche a conexão com o banco de dados\r\n-          if conexao:\r\n-               cursor.close()\r\n-               conexao.close()\r\n-          \r\n-     return dados_descriptrografado\r\n      \n\\ No newline at end of file\n"
                },
                {
                    "date": 1700771312700,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,5 @@\n #Funções para criptografar os dados\r\n-from bs4 import BeautifulSoup\r\n from datetime import datetime\r\n from cryptography.fernet import Fernet\r\n import json\r\n import tempfile\r\n"
                }
            ],
            "date": 1700771052570,
            "name": "Commit-0",
            "content": "#Funções para criptografar os dados\r\ndef cript(nome):\r\n     cipher_suite = Fernet(chave_bytes)\r\n     print(cipher_suite)\r\n     texto_criptografado = cipher_suite.encrypt(json.dumps(nome, ensure_ascii=False).encode('utf-8'))\r\n     return texto_criptografado\r\n\r\ndef descriptografia_e_envio(texto_criptografado,sua_tabela,chave_unica):\r\n     # Configurações de conexão SFTP\r\n     host = os.getenv('host')\r\n     username = os.getenv('username')\r\n     port = 22  # Porta padrão para SFTP\r\n     password = os.getenv('password')  # ou use chave privada com cnopt.private_key_file\r\n     cnopts = pysftp.CnOpts()\r\n     cnopts.hostkeys = None  # Desativa a verificação do hostkey\r\n     \r\n     with tempfile.NamedTemporaryFile(delete=False, suffix='.txt') as temp_file:\r\n          temp_filename = temp_file.name\r\n          temp_file.write(texto_criptografado)\r\n          temp_file.seek(0)\r\n          temp_file.close()\r\n          \r\n\r\n          with pysftp.Connection(host, username=username, password=password, port=port, cnopts=cnopts) as sftp:\r\n               remote_path_upload = r'C:\\Users\\Lenovo\\Desktop\\Projeto Data WH\\saida dados\\teste.txt'\r\n               sftp.put(temp_filename, remote_path_upload)\r\n               \r\n               \r\n               os.remove(temp_filename)\r\n          \r\n               # Fazer download de um arquivo do servidor SFTP\r\n               remote_path_download = r'C:\\Users\\Lenovo\\Desktop\\Projeto Data WH\\saida dados\\teste.txt'\r\n               local_path_download = 'caminho_do_arquivo_remoto_para_baixar.txt'\r\n               sftp.get(remote_path_download, local_path_download)\r\n                \r\n       \r\n     # Descriptografar os dados do arquivo criptografado\r\n     with open(local_path_download, 'rb') as arquivo_criptografado:\r\n          dados_criptografados = arquivo_criptografado.read().decode('utf-8') \r\n          cipher_suite = Fernet(chave_bytes)      \r\n          texto_descriptrografado = cipher_suite.decrypt(dados_criptografados)\r\n          dados_descriptrografado = texto_descriptrografado.decode('utf-8')\r\n          dicionario_descriptrografado = json.loads(dados_descriptrografado)\r\n          \r\n          \r\n     chaves = []\r\n     valores = []\r\n     \r\n     for dicionario in dicionario_descriptrografado:\r\n          for chav, valor in dicionario.items():\r\n               chaves.append(chav)\r\n               valores.append(valor)\r\n               \r\n               \r\n     db_config = {\r\n          'host': os.getenv('DBhost'),\r\n          'database': os.getenv('DBdatabase'),\r\n          'user': os.getenv('DBuser'),\r\n          'password': os.getenv('DBpassword')\r\n     }\r\n     \r\n     # Crie uma conexão com o banco de dados PostgreSQL\r\n     try:\r\n          conexao = psycopg2.connect(**db_config)\r\n          cursor = conexao.cursor()\r\n          ######################################################################################\r\n          # Consulte o banco de dados para obter as chaves existentes\r\n          consulta_sql = f\"SELECT {chave_unica} FROM {sua_tabela};\"\r\n          # Execute a consulta SQL\r\n          cursor.execute(consulta_sql)\r\n          dados_do_banco = cursor.fetchall()\r\n          print(consulta_sql)\r\n          \r\n          # Execute a consulta SQL para obter as chaves únicas existentes no banco de dados\r\n          chave_desejada = f\"{chave_unica}\"\r\n          \r\n          chaves_existente = [valor for tupla in dados_do_banco for valor in tupla]\r\n          chaves_existente = set(chaves_existente)\r\n          print(chaves_existente)\r\n\r\n          chaves_novas = {dicionario[chave_desejada] for dicionario in dicionario_descriptrografado}\r\n          print(chaves_novas)\r\n\r\n      \r\n\r\n          # Importe apenas as chaves que ainda não existem no banco de dados\r\n          novas_chaves = chaves_novas - chaves_existente\r\n          print(novas_chaves)\r\n          \r\n          dados_para_inserir = []\r\n\r\n          for dicionario in dicionario_descriptrografado:\r\n          # Verifica se a chave desejada está presente no dicionário\r\n               if dicionario[chave_desejada] in novas_chaves:\r\n                    # Adiciona o dicionário completo à lista\r\n                    dados_para_inserir.append(dicionario)\r\n                    # Construa a consulta SQL INSERT\r\n          for dicionario_inserir in dados_para_inserir:\r\n               consulta_sql = f\"INSERT INTO {sua_tabela} ({', '.join(dicionario_inserir.keys())}) VALUES ({', '.join(['%s' for _ in dicionario_inserir.values()])})\"\r\n\r\n               # Execute a consulta SQL\r\n               cursor.execute(consulta_sql)\r\n\r\n               # Faça commit para confirmar a transação\r\n               conexao.commit()\r\n               print(\"Inserção bem-sucedida.\")\r\n\r\n     except Exception as e:\r\n          print(\"Erro ao executar a consulta SQL:\", e)\r\n          # Lide com o erro conforme necessário\r\n\r\n     finally:\r\n     # Feche a conexão com o banco de dados\r\n          if conexao:\r\n               cursor.close()\r\n               conexao.close()\r\n          \r\n     return dados_descriptrografado\r\n     "
        }
    ]
}